#include "obaq.as"

//画面設定*************************************
physicsWidth=750.0	// 物理演算画面サイズ
physicsHeight=375.0	// 
pictureWidth=1500.0	// 絵画画面サイズ
pictureHeight=600.0	// 
paletSize=300		// 喜怒哀楽画面サイズ
// 絵画画面
bgscr 0,pictureWidth,pictureHeight,,0,0
;screen 0,,pictureWidth,pictureHeight,,0,0
cls 4
title "picture"
line pictureWidth/2,pictureHeight/2,pictureWidth/2,pictureHeight/2
// 物理演算画面
bgscr 1,physicsWidth,physicsHeight,,0,pictureHeight
;screen 1,physicsWidth,physicsHeight,,0,pictureHeight
cls 4
title "drawing"
// 喜怒哀楽パレット
kidox=paletSize/2:kidoy=paletSize/2
bgscr 2,paletSize,paletSize,,pictureWidth,50
#uselib "gdi32" 
#cfunc CreateEllipticRgn "CreateEllipticRgn" int, int, int, int
#uselib "user32"
#func SetWindowRgn "SetWindowRgn" int, int, int
hRegion = CreateEllipticRgn (0, 0, paletSize, paletSize)
SetWindowRgn hwnd, hRegion, 1
gsel 1
//*********************************************

// obaqの初期化
qreset

// オブジェクトの追加・設定********************
randomize
// 筆用オブジェクト
qaddpoly brush,50,physicsWidth/8,physicsHeight/8,,10,10,,,,2
qinertia brush,,0
// モブ用オブジェクト
num=40
for i,0,2000,1
	if num==0:_break
	qaddpoly obj,rnd(5)+3,rnd(physicsWidth/4),rnd(physicsWidth/4),,rnd(5)+5,rnd(5)+5,,,,1
	if obj>=0:num--
	qweight obj,rnd(10)+1,rnd(10)+1
	qinertia obj,,0
next
// 外枠
qborder -physicsWidth/8.0,-physicsHeight/8.0,physicsWidth/8.0,physicsHeight/8
//*********************************************
*main
	gsel 2
	gosub *kidoairaku
	gsel 1
	// 筆に当たったオブジェクトの検出
	qcollision brush
	repeat
		qgetcol obj,colx,coly
		if obj<0:break
		// モブに当たった場所に円を描画
		gosub *circledraw
	loop
	// 筆の軌跡
	qgetpos brush,myx,myy,myang
	gsel 0
	color rnd(256),rnd(256),rnd(256)
	line myx*(pictureWidth/physicsWidth)*4,myy*(pictureHeight/physicsHeight)*4
	gsel 1
	// 筆の移動
	stick key,15
	if key&128 : end	// [ESC]キーで終了
	speedx=0.0:speedy=0.0	// カーソルキーで操作
	if key&1 : speedx-=0.05
	if key&4 : speedx+=0.05
	if key&2 : speedy-=0.05
	if key&8 : speedy+=0.05
	qspeed brush, speedx,speedy,0

	redraw 0
		// 背景初期化
		color:boxf
		// オブジェクトの更新
		qexec
		// オブジェクトの描画
		qdraw 0
	redraw 1
	await 1
	goto *main
	

*circledraw
	gsel 0
	color r,g,b
	circle colx*(pictureWidth/physicsWidth)*4-10,coly*(pictureHeight/physicsHeight)*4-10,colx*(pictureWidth/physicsWidth)*4+10,coly*(pictureHeight/physicsHeight)*4+10,0
	gsel 1
	return

*kidoairaku
	onclick gosub *mousepos
	getkey w,87
	getkey a,65
	getkey s,83
	getkey d,68
	if w:kidoy-=5
	if s:kidoy+=5
	if a:kidox-=5
	if d:kidox+=5
	if sqrt((kidox-paletSize/2)*(kidox-paletSize/2)+(kidoy-paletSize/2)*(kidoy-paletSize/2))>paletSize/2{
		kidoy=paletSize/2
		kidox=paletSize/2
	}
	redraw 0
	
	dist=sqrt((kidox-paletSize/2)*(kidox-paletSize/2)+(kidoy-paletSize/2)*(kidoy-paletSize/2))	// 中心からの距離
	distPer=1.0-(dist\(paletSize/2))/(paletSize/2)	// 中心からの割合(0~1)
	radi=atan(kidoy-paletSize/2,kidox-paletSize/2)	//角度
	
	// 左上
	if kidox<=paletSize/2 && kidoy<=paletSize/2{
		r=-255.0*sin(radi)+(255.0+255.0*sin(radi))*distPer
		g=255.0
		b=255.0*distPer
	}
	// 右下
	if kidox>=paletSize/2 && kidoy>=paletSize/2{
		r=255.0*cos(radi)+(255.0-255.0*cos(radi))*distPer
		g=255.0*distPer
		b=255.0*sin(radi)+(255.0-255.0*sin(radi))*distPer
	}
	// 右上
	if kidox>paletSize/2 && kidoy<paletSize/2{
		r=255.0
		g=-255.0*sin(radi)+(255.0+255.0*sin(radi))*distPer
		b=255.0*distPer
	}
	// 左下
	if kidox<paletSize/2 && kidoy>paletSize/2{
		r=255.0*distPer
		g=-255.0*cos(radi)+(255.0+255.0*cos(radi))*distPer
		b=255.0*sin(radi)+(255.0-255.0*sin(radi))*distPer
	}
	
	title str(r)+","+str(g)+","+str(b)
	color r,g,b
	redraw 0
	boxf

	color
	circle 0,0,paletSize,paletSize,0
	circle kidox-20,kidoy-20,kidox+20,kidoy+20
	line 0,paletSize/2,paletSize,paletSize/2
	line paletSize/2,0,paletSize/2,paletSize
	font "meiryo",30
	pos 0,paletSize/2
	mes "楽"
	pos paletSize/2-30,paletSize-40
	mes "哀"
	pos paletSize-40,paletSize/2
	mes "怒"
	pos paletSize/2-30,0
	mes "喜"
	pos paletSize/2,paletSize/2
	mes "無"
	redraw 1
	return

*mousepos
	gsel 2
	kidox=mousex
	kidoy=mousey
	return